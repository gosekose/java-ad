## 자바 정리

- 장점
  - 운영체제에 독립적
    - JVM에서 동작하기 떄문에 플랫폼에 종속적이지 않음
  - 객체 지향 언어
    - 캡슐화, 상속, 추상화, 다형성 등을 지원하여 객체지향 프로그래밍이 가능함
  - 동적 로딩을 지원
    - 애플리케이션이 실행될 때, 모든 객체가 로드되지 않고, 각 객체가 필요한 시점에 동적 로딩해서 생성
- 단점
  - 한번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고, JVM에 의해 기계어로 변역되고 실행되는 과정을 거치므로 조금 느림

---

- 객체지향 프로그래밍의 특징
  - 캡슐화
    - 정보 은닉: 필요없는 정보는 외부에서 접근하지 못하도록 제한
    - 높은 응집도, 낮은 결합도
  - 추상화
    - 사물들의 공통적인 특징을 파악해서 하나의 개념으로 다루는 것
    - 목적과 관련없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념
  - 상속
    - 기존 상위 클래스에 근거하여 새롭게 클래스와 행위를 정의할 수 있게 도와주는 개념
  - 다형성
    - 형태가 같은데 다른 것을 하는 것을 의미
    - 오버라이딩, 오버로딩

---

- SOLID 원칙
  - 단일 책임 원칙
    - 객체는 단 하나의 책임을 가져야 함
    - 어떤 변화에 의해 클래스를 변경해야 하는 이유는 오직 하나뿐이여야 함
  - 개방 폐쇄 원칙
    - 기존 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 함
  - 리스코프 치환 원칙
    - 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 함
  - 인터페이스 분리 원칙
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
    - 인터페이스가 명확해지고 대체 가능성이 높아짐
  - 의존관계 역전 원칙
    - 인터페이스에 의존하라

---

- JVM 실행 과정
  - JVM은 OS로부터 메모리를 할당 받음
  - 컴파일러가 소스코드를 읽어 바이트코드로 변환
  - Class Loader를 통해 Class파일을 JVM내 Runtime Data Area에 로드
  - 로딩된 Class 파일을 Execution Engine을 통해 해석

---

- JVM 메모리 구조
  - 메소드 (static) 영역
    - 클래스가 사용되면 해당 클래스의 파일을 읽어들여, 클래스에 대한 정보를 메서드 영역에 저장
    - 클래스와 인터페이스, 메서드, 필드, static 변수, final 변수 등이 저장되는 영역
  - JVM 힙 영역
    - 런타임 시 동적으로 할당하여 사용
    - new 연산자로 생성된 객체와 배열 저장
    - 참조가 없는 객체는 GC의 대상
  - JVM 스택 영역
    - 스레드마다 존재하여 스레드가 시작할 떄마다 할당
    - 지역변수, 매개변수, 연산 중 발생하는 임시 데이터를 저장
    - 메서드 호출 시마다 개별적 스택 생성
  - PC 레지스터
    - 쓰레드가 현재 실행할 스택 프레임의 주소를 저장
  - Native Method Stack
    - C/C++ 등의 Low level 코드를 실행하는 스택

---

- GC
  - 가비지 컬렉터는 동적으로 할당한 메모리 영역 중 사용하지 않는 영역을 탐지하여 해제하는 역할
  - 자바 가비지 컬렉터는 Mark And Sweep 알고리즘 사용
    - Java8: Parallel GC 
      - 여러 개의 쓰레드로 GC를 실행하는 방식
    - Java9: G1 GC
      - Garbage First의 줄임말로 Heap의 일정 크기의 Region으로 나눠서 어떤 영역은 Young Generation, 어떤 영역은 Old Generation으로 활용
      - 런타임에 따라 G1 GC가 영역별 Region 개수를 튜닝
  - 동작 과정
    - 새로운 객체 생성은 Heap의 Eden 영역에 저장
    - Eden 영역이 꽉차면 Minor GC가 수행, Reachable 객체는 Survival 0 이동, age-bit 1 증가
    - 2번 과정이 반복되면서 Survival 0 -> 1 이동 bit + 1
    - age-bit가 일정 값 이상이 되면, 해당 객체에 대해 promotion 과정이 진행, Old Generation 영역으로 이동
    - Old Generation 영역이 꽉차면 Major GC가 수행
  - Stop The World
    - GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것
    - 모든 GC는 STW를 발생시키는데, Minor GC는 객체의 수명이 짧고 많은 객체를 검사하지 않기 때문에 매우 빨라 애플리케이션에 거의 영향 X
    - Major GC는 살아있는 모든 객체를 검사해야 하기 떄문에 오랜 시간이 소요

--- 
- Call By Value vs Call By Reference
  - Call By Value
    - 함수 호출 시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달
    - 함수 안에서 인자의 값이 변경되어도, 외부의 변수 값은 변경 X
  - Call By Reference (참조에 의한 호출)
    - 함수 호출 시 인자로 전달되는 변수의 레퍼런스를 전달
    - 함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경

---

- non-static
  - 공간적 특성
    - 객체마다 별도 존재, 인스턴스 변수
  - 시간적 특성
    - 객체와 생명주기가 동일
- static
  - 공간적 특성
    - 클래스당 하나만 생성
    - 동일한 클래스의 모든 객체들에 의해 공유
  - 시간적 특성
    - 객체가 생기기 전에 이미 생성되어 객체를 생성하지 않아도 사용 가능
    - 객체가 사려져도 사라지지 않음
    - 프로글매 종료시에 사라짐

---

- main이 static인 이유
    - static 멤버는 프로그램 시작시 메모리에 로드되어 인스턴스를 생성하지 않아도 호출이 가능
    - 실행 과정
      - 코드를 실행하면 컴파일러가 .java를 .class 바이트 코드로 변환
      - 클래스 로더가 .class 파일을 메모리 영역에 로드
      - Runtime Data Area 중 Method Area라고 불리는 영역에 Class Variable이 저장
      - static 변수도 여기에 저장

---

- final vs finally vs finalize
    - final
      - 변수, 메서드 클래스가 변경 불가능하도록 만듬
      - 기본 타입 변수에 선언
        - 해당 변수의 값 변경 불가
      - 참조 변수에 적용 시 
        - 참조 변수가 힙 내의 다른 객체를 가리키도록 변경 불가
      - 메소드에 적용
        - 해당 메서드를 오버라이드할 수 없음 
        - 오버로딩은 가능
      - 클래스에 적용 시
        - 해당 클래스를 상속 받아서 사용할 수 없음
    - finally
      - try catch 블록 뒤에서 항상 실행될 코드 불록을 정의하기 위해 사용
    - finalize
      - 객체가 GC에 의해 수집되기 전에 마지막으로 실행할 코드 불록을 정의하기 위해 사용
 
---

- try with resources
  - 자바 7 이전에는 try-catch-finally에서는 리소스 생성을 try 구문에서, 리소스 반납을 finally에서 함
  - 실수 발생 여지 존재
  - 자바 7 이후에는 try with resources 구문이 나옴 try 옆 괄호 안에서 리소스를 생성해주면 따로 반납하지 않아도 리소스를 자동으로 반납

---

- 직렬화
  - 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 형태로 데이터를 변환
  - 조건
    - 자바 기본 타입
    - Serializable 인터페이스르 상속받은 객체
  - ObjectOutputStream 객체를 이용
- 역직렬화
  - 바이트로 변환된 데이터를 다시 객체로 변환
  - ObjectInputStream 객체를 이용

---

- 추상 클래스와 인터페이스 차이
  - 추상 클래스와 인터페이스 모두 구현을 강제
  - 추상 클래스의 추상 메서드는 default 제공 불가
  - 인터페이스는 default 제공 가능
  - 논리적인 관점에서 보면 추상 클래스와 인터페이스 모두 다형성을 구현하기 위한 방법
  - 추상 클래스는 상속을 통해 구현하므로 더 엄격한 계층 구조
  - 인터페이스는 여러 개를 구현할 수 있기 떄문에 더 유연한 다형성 구현 방법

---

- Checked Exception
  - RuntimeException 상속 X
  - 컴파일 시점
  - 반드시 예외처리
  - 예외 발생시 롤백 X
  - IOException, SQLException
- Unchecked Exception
  - RuntimeException 상속
  - 런타임 시점
  - 명시적으로 하지 않음
  - 예외 발생시 롤백
  - NullPointExceion

---

- Map
  - HashMap
    - 내부의 hash값에 따라 키순서가 정해지므로 특정 규칙없이 출력
    - key, value에 null값 허용
    - 동기화 x
  - LinkedHashMap
    - 입력 순서대로 출력
    - 동기화 x
  - TreeMap
    - 내부적으로 레드-블랙 트리로 저장
    - Null값 비허용
    - 키값이 기본적으로 오름차순 정렬 되어 출력
    - Comparator를 이용하여 정렬
  - ConcurrentHashMap
    - key, value에 null값 비허용
    - 동기화 O
  - Hashtable
    - key, value에 null값 비허용
    - 동기화 O

---

- Set
  - HashSet
    - 중복을 허용하지 않음
    - 순서가 없음
    - 동기화 x
    - null값 허용
    - 내부적으로 HashMap을 사용
  - LinkedHashSet
    - 입력 순서대로 출력
  - TreeSet
    - 중복을 허용하지 않음
    - Null값 비허용
    - 레드 블랙 트리로 구현
    - Comparator를 이용하여 정렬
  - Collections.synchronizedSet
    - 동기화 
    - 성능이 다소 떨어짐
  - ConcurrentSkipListSet
    - 동기화
    - 고속, 정렬된 순서 유지
    - 메모리 사용량 많음
  - CopyOnWriteArraySet
    - 읽기 작업이 빈번하고 쓰기 작업이 드문 경우에 적합
    - 내부적으로 복사-쓰기 메커니즘을 사용하여 읽기 작업의 성능을 최적화
    - 쓰기 작업이 빈번한 경우 성능이 떨어짐


---

- List
  - ArrayList
    - 내부적으로 배열을 사용하는 자료구조로 메모리가 연속으로 배치
    - 배열과 달리 메모리 할당이 동적
    - 데이터 삽입, 삭제 시 해당 데이터 이후 모든 데이터가 복사, 빈번한 삭제, 삽입이 일어나는 경우에는 부적합
    - 검색의 경우 인덱스의 데이터를 가져오면 되므로 빠름
    - 재할당 시 크기의 절반씩 증가
  - LinkedList
    - 양방향 포인터 구조로 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료 구조
    - 데이터의 삽입, 삭제 시 해당 노드의 주소지만 바꾸면 되므로, 삽입, 삭제가 빈번한 데이터에 적합
    - 메모리가 불연속적
    - 데이터 검색 시 처음부터 순회하므로 검색에는 부적합
    - 스택, 큐, 양방향 큐를 만들기 위한 용도로 사용

--- 

- 리플렉션
  - 런타임 상황에서 메모리에 올라간 클래스나 메서드 등의 정의를 동적으로 찾아서 조작할 수 있는 기술
  - 컴파일 시간이 아닌 실행 시간에 동적으로 특정 클래스의 정보를 객체화를 통해 분석 및 추출
  - 자바에서 이미 로딩이 완료된 클래스에서 또 다른 클래스로 동적로딩하여 생성자, 필드, 메서드 등을 사용할 수 있음
  
---

- Stream
  - java 8에서 추가된 API
  - 컬렉션 타입의 데이터를 Stream 메서드로 내부 반복을 통해 정렬, 필터링 등이 가능
  - 특징
    - parallel 메서드 제공을 통해 병렬처리 가능
      - 각 스레드가 개별 큐를 가지고 있음
      - 놀고 있는 스레드가 있으면 일하는 스레드의 작업을 가져와 수행
    - 데이터를 변경하지 않음
      - 원본데이터로부터 데이터를 읽음, 원본 데이터 자체를 변경하지 않음
      - 작업을 내부 반복으로 처리, 불필요한 코딩 줄임
      - 최종 연산 후 stream이 닫히므로 일회용
  - 구조
    - Stream 생성
      - 중간 연산
        - 데이터를 가공하는 과정
          - 필터링:filter, distinct
          - 변환: map, flatMap
          - 제한: limit, skip
          - 정렬: sorted
          - 연산 결과 확인 peek
      - 최종연산
        - Stream의 데이터를 모아 반환
        - 출력
          - forEach
        - 소모
          - reduce
        - 검색
          - findFirst, findAny
        - 검사
          - anyMatch, allMatch, noneMatch
        - 통계
          - count, min, max
        - 연산
          - sum, average
        - 수집
          - collect
  - 중간 연산 작업은 바로 실행되는 것이 아니라 종결 처리의 실행이 필요할 때 비로소 중간 처리 실행
  - ParallelStream
    - 개발자가 직업 스레드 혹은 스레드 풀을 생성하거나 관리할 필요 없이, parallelStream, parallel()만 사용하면 알아서 내부적으로 common ForkJoinPool을 사용
    - forkJoinPool은 ExecutorService의 구현체로 각 스레드별 개별 큐를 가지고 스레드에 아무런 task가 없으면 다른 스레드의 task를 가져와 처리
    - 내부적으로 스레드 풀을 만들어서 작업을 병렬화
    - 중요한 점은 parallelStream 각각 스레드 풀을 만드는게 아니라 별도으 ㅣ설정이 없다면 하나의 스레드 풀을 모든 parallelStream이 공유
    - ParallelStream은 중간 연산에서 순서가 보장되지 않기 때문에 중간 연산에서 순서에 관계없는 연산의 경우에 사용

---
- 람다식
  - 자바 8에서 등작
  - 메서드를 하나의 식으로 표현하는 익명 함수
  - 인터페이스 내에 한 개의 추상 메서드만 정의되어 있는 함수형 인터페이스에서 사용
  - 장점
    - 병렬 프로그래밍 용이
    - 익명 함수로 작성하던 코드를 줄임

---
- Optional
  - T orElse
    - 반환할 값을 그대로 받음
    - 무조건 인스턴스화
  - T orElseGet(supplier<? extends T> other)
    - Supplier로 랩핑된 값을 인자로 받음
    - 함수를 전달받아 바로 값을 가져오지 않고 필요할 때 Lazy하게 가져옴
    - Optional 안의 값이 null일 경우에만 함수가 실행