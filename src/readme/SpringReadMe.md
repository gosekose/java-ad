## 프레임워크와 라이브러리
- 제어 흐름에 대한 주도권이 어디에 있는가의 차이
  - 프레임워크: 응용 프로그램이나 소프트웨어 솔루션 개발을 수월하게 하기 위해 틀이 제공된 소프트웨어 환경
  - 라이브러리: 특정 기능을 수행하는 코드 집합
- 프레임워크의 경우 제어 흐름을 스스로 가지고 있음
- 라이브러리는 제어 흐름을 개발자가 가지고 있음

---

## Spring
- 스프링은 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크
- 동적인 웹 사이트를 개발하기 위한 여러 가지 서비스르 제공
- POJO 기반의 구성으로 자바 코드를 이용해서 객체를 구성하는 방식 그대로 스프링에 적용 가능
- DI(의존성 주입)을 통한 객체 관계 구성을 지원
- AOP 지원
- MVC 구조로 계층이 분리되어 관리하기 수월
- 배치 애플리케이션 스프링 배치가 있음

---

## DI (Dependency Injection)
- DI는 스프링프레임워크에서 지원하는 IoC 형태
- 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결
- 장점
  - 스프링 자체에서 설정을 통해 연관관계를 맺어주어 객체간 결합도를 낮춤
  - 클래스의 재사용성을 높임
  - 의존성 주입으로 stub, mock 객체를 사용해 unit 테스트의 이점이 있음

---

## IoC 제어의 역전
- 객체의 생성부터 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀐 것
- 개발자는 프레임워크에 필요한 부품을 개발하고 조립하는 방식으로 개발을 하고, 최종 호출은
- 프레임워크 내부에서 결정된 대로 이뤄짐

---

## 스프링 컨테이너
- 스프링 컨테이너는 자바 객체의 생명 주기를 관리
- 생성된 자바 객체들에게 추가적인 기능을 제공
- 빈의 생명 주기를 관리
- 스프링 컨테이너 안에서 관리되는 객체

---

## Bean 생명주기
- 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존 관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
- 스프링 컨테이너 초기화 시 빈 객체 생성, 의존 객체 주입 및 초기화
- 생성과 의존관계 주입과 초기화 분리
  - 의존관계 주입은 필수정보를 받고 메모리 할당을 통해 객체 생성 책임
  - 초기화는 생성된 값들을 활용해 외부 커넥션을 연결하는 등 무거운 작업 수행
- 싱글톤 빈들은 컨테이너가 종료되기 직전에 소멸전 콜백이 발생

---

## Bean 스코프
- 싱글톤: spring 프레임워크의 기본이 되는 스코프
  - 스프링 컨테이너 시작과 종료까지 1개의 객체로 유지
- 프로토타입
  - 빈의 생성, 의존관계 주입, 초기화까지만 관여하고 이후에는 컨테이너에서 관리하지 않는 스코프
  - 매 요청마다 새로 생성
- 웝 스코프
  - request
  - session
  - application
    - 서블릿 컨텍스트는 web application 내에 있는 모든 서블릿들을 관리하며 정보 공유할 수 있게 돕는 역할
    - 톰켓 컨테이너가 실행 시 애플리케이션 하나 당 한개의 서블릿 컨텍스트 생성
    - 생명주기는 보통 톰켓의 시작 종료와 일치

---

## Web 서버와 웹 애플리케이션 서버
- 웹 서버
  - 정적 리소스 파일을 제공
- 웹 애플리케이션 서버(WAS)
  - 웹 서버가 하는 일, 애플리케이션 로직까지 제공하여 동적인 처리를 하는 서버
  - 자바 진영에서는 서블릿 컨테이너 기능을 제공하면 WAS라 함
  - WAS 안에서도 웹서버가 존재

---

## 서블릿
- 서블릿은 WAS 안에서 동적인 페이지를 만드는데 사용되는 서버 프로그램
- 서블릿이 존재하기 전에는 요청이 들어오면 HTTP 요청 메세지를 파싱하는 것부터 여러 부가 작업을 개발자가 수행
- 서블릿이 나오면서 부가적인 작업을 대신 해줌
- 실질적인 메인 로직에만 집중

---

## 서블릿 컨테이너

- 스프링 컨테이너와 마찬가지로 서블릿 생명주기를 관리
  - init: 서블릿 초기화
  - service: HTTP 요청 유형을 확인하고, doGet, doPost, doPut 등 메서드를 호출
  - destroy: 서블릿 제거
- 요청 시 동작 과정
  - 사용자가 URL을 클릭하면 Http Request Servlet Container로 보냄
  - Servelt Container는 쓰레드 풀에서 쓰레드를 꺼내 할당
  - HttpServeltRequest, HttpServletResponse 객체를 생성
  - 사용자가 요청한 URL을 분석하여 어느 서블릿인지 요청을 찾음
  - 서블릿 컨테이너가 존재하지 않으면 초기화하고 가져온 후 service() 호출
    - Spring MVC의 경우 DispatcherServlet이 초기화되고 호출
  - service 메서드가 수행이 끝나면 HttpServletResponse 객체에 응답을 보냄
  - 응답이 완료되면, HttpServletRequest, HttpServletResponse 객체를 소멸

---

### MVC 패턴
- 핸들러 조회
  - 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러를 조회
- 핸들러 어댑터 조회
  - 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
- 핸들러 어댑터 실행
  - 조회한 핸들러를 인자로 핸들러 어댑터에 넘겨서 핸들러를 실행
- ModelAndView
  - 핸들러가 로직을 수행하고 반환하는 정보로 ModelAndView로 변환해서 반환
- viewResolver 호출
  - 적절한 viewResolver를 찾고 해당 viewResolver를 호출
  - RestControlelr라면 이 과정 없이 컨버터를 이용해 바로 결과값을 리턴
- View 반환
  - viewResolver는 뷰의 논리 이름을 물리 이름으로 바꾸고, 랜더링 역할을 담당하는 뷰 객체를 반환

---

## 싱글톤 패턴을 안전하게 만들기
- 지역변수 사용
- Atomic 자료형 사용
- ThreadLocal 사용
- Synchronized 사용

---

## AOP 
- 관점 지향 프로그래밍으로 공통 관심 사항과 핵심 관심 사항을 분리하는 것
- 소스 코드에서 여러 번 반복해서 사용하는 코드를 Aspect로 모듈화
- 핵심 로직에서 분리해 재사용 하는 것

---

## AOP 적용 시점
- 컴파일 시점
- 클래스 로딩 시점
- 런타임 시점
  - 스프링이 사용하는 방식
  - 런타임 시점에 프록시를 사용하여 실제 대상 코드는 그대로 유지
  - 프록시를 통해 부가 기능이 적용
  - 프록시는 메서드 오버라이딩 개념으로 동작, 메서드에서만 적용 가능
  - 특별한 컴파일러나 복잡한 옵션, 클래스 로더 조작기를 사용하지 않아도 스프링만 잇으면 AOP를 적용

## AOP 적용 과정
- 스프링 빈 대상이 되는 객체를 생성 (@Bean, 컴포넌트 스캔 대상)
- 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달
- 모든 Advisor 빈을 조회
- @Aspect Advisor 빌더 내부에 저장된 모든 Advisor를 조회
- 3, 4에서 조회한 Advisor에 포함되어 있는 포인트컷을 통해 클래스와 메서드 정보를 매칭하면서 프록시를 적용할 대상인지 아닌지 판단
- 여러 Advisor의 하나라도 포인트컷의 조건을 만족한다면, 프록시를 생성하고 원본 빈 대신 프록시 빈을 저장서로 반환
- 프록시 생성 대상이 아니라면 들어온 빈 그대로 빈 저장소로 반환
- 빈 저장소는 객체를 받아서 빈으로 등록