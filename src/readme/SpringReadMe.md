## 프레임워크와 라이브러리
- 제어 흐름에 대한 주도권이 어디에 있는가의 차이
  - 프레임워크: 응용 프로그램이나 소프트웨어 솔루션 개발을 수월하게 하기 위해 틀이 제공된 소프트웨어 환경
  - 라이브러리: 특정 기능을 수행하는 코드 집합
- 프레임워크의 경우 제어 흐름을 스스로 가지고 있음
- 라이브러리는 제어 흐름을 개발자가 가지고 있음

---

## Spring
- 스프링은 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크
- 동적인 웹 사이트를 개발하기 위한 여러 가지 서비스르 제공
- POJO 기반의 구성으로 자바 코드를 이용해서 객체를 구성하는 방식 그대로 스프링에 적용 가능
- DI(의존성 주입)을 통한 객체 관계 구성을 지원
- AOP 지원
- MVC 구조로 계층이 분리되어 관리하기 수월
- 배치 애플리케이션 스프링 배치가 있음

---

## DI (Dependency Injection)
- DI는 스프링프레임워크에서 지원하는 IoC 형태
- 클래스 사이의 의존관계를 빈 설정 정보를 바탕으로 컨테이너가 자동으로 연결
- 장점
  - 스프링 자체에서 설정을 통해 연관관계를 맺어주어 객체간 결합도를 낮춤
  - 클래스의 재사용성을 높임
  - 의존성 주입으로 stub, mock 객체를 사용해 unit 테스트의 이점이 있음

---

## IoC 제어의 역전
- 객체의 생성부터 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀐 것
- 개발자는 프레임워크에 필요한 부품을 개발하고 조립하는 방식으로 개발을 하고, 최종 호출은
- 프레임워크 내부에서 결정된 대로 이뤄짐

---

## 스프링 컨테이너
- 스프링 컨테이너는 자바 객체의 생명 주기를 관리
- 생성된 자바 객체들에게 추가적인 기능을 제공
- 빈의 생명 주기를 관리
- 스프링 컨테이너 안에서 관리되는 객체

---

## Bean 생명주기
- 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존 관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
- 스프링 컨테이너 초기화 시 빈 객체 생성, 의존 객체 주입 및 초기화
- 생성과 의존관계 주입과 초기화 분리
  - 의존관계 주입은 필수정보를 받고 메모리 할당을 통해 객체 생성 책임
  - 초기화는 생성된 값들을 활용해 외부 커넥션을 연결하는 등 무거운 작업 수행
- 싱글톤 빈들은 컨테이너가 종료되기 직전에 소멸전 콜백이 발생

---

## Bean 스코프
- 싱글톤: spring 프레임워크의 기본이 되는 스코프
  - 스프링 컨테이너 시작과 종료까지 1개의 객체로 유지
- 프로토타입
  - 빈의 생성, 의존관계 주입, 초기화까지만 관여하고 이후에는 컨테이너에서 관리하지 않는 스코프
  - 매 요청마다 새로 생성
- 웝 스코프
  - request
  - session
  - application
    - 서블릿 컨텍스트는 web application 내에 있는 모든 서블릿들을 관리하며 정보 공유할 수 있게 돕는 역할
    - 톰켓 컨테이너가 실행 시 애플리케이션 하나 당 한개의 서블릿 컨텍스트 생성
    - 생명주기는 보통 톰켓의 시작 종료와 일치

---

## Web 서버와 웹 애플리케이션 서버
- 웹 서버
  - 정적 리소스 파일을 제공
- 웹 애플리케이션 서버(WAS)
  - 웹 서버가 하는 일, 애플리케이션 로직까지 제공하여 동적인 처리를 하는 서버
  - 자바 진영에서는 서블릿 컨테이너 기능을 제공하면 WAS라 함
  - WAS 안에서도 웹서버가 존재

---

## 서블릿
- 서블릿은 WAS 안에서 동적인 페이지를 만드는데 사용되는 서버 프로그램
- 서블릿이 존재하기 전에는 요청이 들어오면 HTTP 요청 메세지를 파싱하는 것부터 여러 부가 작업을 개발자가 수행
- 서블릿이 나오면서 부가적인 작업을 대신 해줌
- 실질적인 메인 로직에만 집중

---

## 서블릿 컨테이너

- 스프링 컨테이너와 마찬가지로 서블릿 생명주기를 관리
  - init: 서블릿 초기화
  - service: HTTP 요청 유형을 확인하고, doGet, doPost, doPut 등 메서드를 호출
  - destroy: 서블릿 제거
- 요청 시 동작 과정
  - 사용자가 URL을 클릭하면 Http Request Servlet Container로 보냄
  - Servelt Container는 쓰레드 풀에서 쓰레드를 꺼내 할당
  - HttpServeltRequest, HttpServletResponse 객체를 생성
  - 사용자가 요청한 URL을 분석하여 어느 서블릿인지 요청을 찾음
  - 서블릿 컨테이너가 존재하지 않으면 초기화하고 가져온 후 service() 호출
    - Spring MVC의 경우 DispatcherServlet이 초기화되고 호출
  - service 메서드가 수행이 끝나면 HttpServletResponse 객체에 응답을 보냄
  - 응답이 완료되면, HttpServletRequest, HttpServletResponse 객체를 소멸

---

### MVC 패턴
- 핸들러 조회
  - 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러를 조회
- 핸들러 어댑터 조회
  - 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
- 핸들러 어댑터 실행
  - 조회한 핸들러를 인자로 핸들러 어댑터에 넘겨서 핸들러를 실행
- ModelAndView
  - 핸들러가 로직을 수행하고 반환하는 정보로 ModelAndView로 변환해서 반환
- viewResolver 호출
  - 적절한 viewResolver를 찾고 해당 viewResolver를 호출
  - RestControlelr라면 이 과정 없이 컨버터를 이용해 바로 결과값을 리턴
- View 반환
  - viewResolver는 뷰의 논리 이름을 물리 이름으로 바꾸고, 랜더링 역할을 담당하는 뷰 객체를 반환

---

## 싱글톤 패턴을 안전하게 만들기
- 지역변수 사용
- Atomic 자료형 사용
- ThreadLocal 사용
- Synchronized 사용

---

## AOP 
- 관점 지향 프로그래밍으로 공통 관심 사항과 핵심 관심 사항을 분리하는 것
- 소스 코드에서 여러 번 반복해서 사용하는 코드를 Aspect로 모듈화
- 핵심 로직에서 분리해 재사용 하는 것

---

## AOP 적용 시점
- 컴파일 시점
- 클래스 로딩 시점
- 런타임 시점
  - 스프링이 사용하는 방식
  - 런타임 시점에 프록시를 사용하여 실제 대상 코드는 그대로 유지
  - 프록시를 통해 부가 기능이 적용
  - 프록시는 메서드 오버라이딩 개념으로 동작, 메서드에서만 적용 가능
  - 특별한 컴파일러나 복잡한 옵션, 클래스 로더 조작기를 사용하지 않아도 스프링만 잇으면 AOP를 적용

## AOP 적용 과정
- 스프링 빈 대상이 되는 객체를 생성 (@Bean, 컴포넌트 스캔 대상)
- 생성된 객체를 빈 저장소에 등록하기 직전에 빈 후처리기에 전달
- 모든 Advisor 빈을 조회
- @Aspect Advisor 빌더 내부에 저장된 모든 Advisor를 조회
- 3, 4에서 조회한 Advisor에 포함되어 있는 포인트컷을 통해 클래스와 메서드 정보를 매칭하면서 프록시를 적용할 대상인지 아닌지 판단
- 여러 Advisor의 하나라도 포인트컷의 조건을 만족한다면, 프록시를 생성하고 원본 빈 대신 프록시 빈을 저장서로 반환
- 프록시 생성 대상이 아니라면 들어온 빈 그대로 빈 저장소로 반환
- 빈 저장소는 객체를 받아서 빈으로 등록

---

## JDK 동적 프록시
- JDK 동적 프록시의 경우 대상의 인터페이스가 있으면 해당 인터페이스의 구현체로 프록시 생성
- 실제로 구현된 다른 JDK 동적 프록시의 구현체로 타입 캐스팅이 불가능

## CGLIB
- CGLIB는 구현체를 상속받아 프록시를 생성, 구현체로 타입 캐스팅 가능

---

## DAO
- DB 데이터를 조회하거나 조작하는 기능을 전담하는 객체
- DB 접근 로직과 비즈니스 로직을 분리하기 위해서 사용

## DTO
- 계층간의 데이터 교환을 위한 객체
- 로직을 갖지 않는 순수한 데이터 객체로 getter, setter만 포함

## VO
- 읽기 전용으로 불변 객체
- getter, setter 이외의 추가 로직 포함 가능

---

## Filter
- Filter
  - Dispatcher Servlet에 요청이 전달되기 전/후에 url 패턴에 맞는 모든 요청에 대해 부가작업을 처리하는 기능을 제공
  - 톰캣과 같은 웹 컨테이너 단에서 동작하기 때문에 Spring과 무관한 자원에 대해 동작
  - Spring Context 외부에서 동작, ErrorController에서 예외 처리
  - init
    - 필터 객체를 초기화, 서비스에 추가하기 위한 메서드
    - 웹 컨테이너가 1회 init 메서드를 호출하여 필터 객체를 초기화하면 이후 요청들은 doFilter를 통해 전후 처리가 됨
  - doFilter
    - url-pattern에 맞는 모든 HTTP 요청이 디스패처 서블릿으로 전달되기 전/후에 웹 컨테이너에 의해 실행되는 메서드
    - doFilter의 파라미터로 FilterChain이 있는데, FilterChain의 doFilter를 통해 다음 대상으로 요청을 전달
  - destroy
    - 필터 객체를 서비스에서 제거하고 사용하는 자원을 반환하는 메서드
    - 웹 컨테이너에 의해 1번 호출
  - 참고로 필터를 추가하기 위해서는 javax.servlet의 Filter 인터페이스를 구현

---

## Interceptor

- Spring이 제공하는 기술로, Dispatcher Servlet이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능 제공
- 스프링 컨텍스트에서 동작
- Spring Context 내부에서 동작하므로 @ControllerAdvice를 사용하여 예외 처리
- preHandle
  - 컨트롤러가 호출되기 전에 실행되어 컨트롤러 이전에 처리해야하는 전처리 작업이나 요청 정보를 가공
- postHandle
  - 컨트롤러가 호출된 후에 실행
  - 보통 컨트롤러가 반환하는 ModelAndView 타입의 정보
- afterConpletion
  - 모든 뷰에서 최종 결과를 생성하는 일을 포함해 모든 작업이 완료된 후에 실행
  - 요청 처리 중에 사용한 리소스를 반환할 때 사용하기 적합
- 인터셉터를 추가하기 위해서는 HandlerInterceptor 인터페이스 구현
- 실행 과정
  - 서버 실행 시 Servlet이 올라오는 동안 init 후 doFilter 실행
  - Dispatcher Servlet을 지나처 Interceptor의 PreHandler 실행
  - 컨트롤러를 거쳐 내부 로직 수행 후, Interceptor의 PostHandler 실행
  - doFilter 실행
  - Servlet 종료 시 destory 실행

---

## 커넥션 풀
- 애플리케이션이 데이터베이스를 사용하기 위해서는 커넥션을 맺어야 함
- 커넥션을 생성하고 소멸시키는 비용이 크기 떄문에 커넥션 풀을 세팅해두고 애플리케이션이 시작하는 시점에 커넥션을 재활용

---

## DataSource
- 커넥션 관련 기술이 여러 개 등장하면서 코드레벨에서는 서로 다르지만 논리적으로는 커넥션을 획득하는 역할을 하기 때문에 이를 추상화 시킨 것이 DataSource
- 실질적인 로직은 DataSource에 의존하도록 하고 구현 기술이 바뀔때마다 DataSource의 구현체만 바꾸면 되므로 재사용성과 확장성을 높일 수 있음
- 커넥션 관련 기술은 커넥션을 계속 신규 생성하는 DriverManager, DBCP 커넥션 풀, HikariCP 커넥션 풀 들이 있음

---

## Transactional의 동작 방식
- 프록시로 동작하므로 오버라이딩 개념으로 동작
- 클래스에 붙으면 클래스 전체 public 메서드에 트랜잭션 처리가 된 프록시가 빈으로 등록
- 서비스단에서 트랜잭션이 시작하면 트랜잭션 매니저가 커넥션을 생성, autoCommit을 false로 세팅
- 트랜잭션 동기화 매니저의 스레드 로컬에 커넥션을 보관
- 리포지토리 계층은 트랜잭션 동기화 매니저의 스레드 로컬에서 해당 커넥션을 가져와서 사용
- 서비스 단에서 트랜잭션을 종료할 때는 트랜잭션 동기화 매니저에서 해당 커넥션을 가져와 커밋 또는 롤백을 수행하고 리소스를 정리
- 커넥션을 커넥션 풀에 반환

---

## ORM
- JDBC API
  - JAVA 진영 Database 연결 표준 인터페이스
- Spring JDBC
  - template을 통해 데이터를 꺼내면서 한단계 더 추상화
- ORM
  - 객체지향 코드와 데이터 중심 데이터베이스의 패러다임 불일치를 해결하기 위해 나온 기술
  - 객체와 관계형 데이터베이스를 매핑하는 기술
- JPA
  - 자바 ORM 표준 API 명세를 JPA 인터페이스라고 함
- Hibernate
  - JPA 구현체 중 하나
- Spring Data JPA
  - JPA에 Repository를 추가하여 한단계 더 추상화

## 상속관계 매핑
- 상속관계 매핑
  - 객체간 상속관계를 DB에 적용시키기 위한 작업
  - 부모 클래스에 @Inheritance 어노테이션을 붙여서 상속관계 명시
  - JOINED 전략이 제일 합리적, 매우 간단하면 SINGLE_TABLE 전략 사용
  - 부모, 자식 클래스 모두 @Entity
  - 전략에 딸 ㅏ부모테이블이 생성될 수도, 안될 수도 있음
- 임베디드 타입
  - MappedSuperclass와 유사하게 공통되는 속성을 뽑아서 만든 클래스로 @Embeddable 어노테이션을 붙임
  - 사용하는 곳에서는 상속이 아니라 필드로 선언, @Embedded 어노테이션 사용
  - 테이블로 올라가지 않음
